
## Quick Start.
- Run the EntityFramework migrations in order to create and upgrade the database.
- The Connection Strategy is set to "managed", which meand the Angular ddevelopment server will launch automatically to supply the runtime files to the MVC controller.
- Invoke the "ToDoList" profile either by selecting it from the VS toolbar and hitting F5, or typing dotnet run --profile "ToDoList" in the console. If the database has been correctly created, the app should run out-of-the-box with no problems. (Thre is a connection string defined, but it isn't used.)

## Aims
There were a few things I wanted to accomplish:
- Use a minimal de elopment framework instead of the built-in dotnet Angular project template. I find this template very messay, with ports scattered over proxy files and project directives.
Instead, I opted to use a setup demonstrated by Adam Freeman in an Angluar/MVC book from a few years ago. This approach has a number of advantages. Firstly, it allows you to embed the Angular runtime files in an MVC controller, giving all the benefites of dotnet tooling - libman.json, bundleConfig, conditional script inclusion, minification, etc. Of course, you can do this in the published version just by copying and pasting the runtime files into the page. But this approach allows you to do it in a dev environment at runtime. Secondly, it gives you more development options. You can either run the application in "managed" mode, which will fire up the Angular dev server automatically, or in "proxy" mode. In the latter case, you have to start the Angular dev server manually first, but it allows change monitoring and instant reloads.
- Reuse a framework I built a few years ago for a large-scale application. This makes use of a client-side repository which mirrors the server-side repository (an approach again based on Adam Freeman's code.) This was quite a large data entry app that I wrote for a medical data company that had many screens. I would have preferred it if the received repository idea was implemented as a service. As it stands, I doesn't have an interface and has to be wired up inside the client. However, one reason for doing that is to allow the provider to be swapped out. But you can actually do that in the REST backend, so maybe it isn't worth doing at the client side.
- DB Repository pattern. The requirement didn't ask for a real database. But repository code is trivially easy to write, and I had plenty on hand, so it didn't take any time to write it. It's a tried and tested solution, and if you want to do unit testing, you need an injectable repository.

## Issues
- The legacy framework was built around an older Angular version (probably 12), and the requirement was to use the most current version, which is 20. For some reason, if you don't specify an Angular version when creating an application, you get version 16. This version turned out to be compatible with my framework, but when I realised it was not the current version (it's now 20), I tried replacing the client-side code. However, version 20 didn't work out-of-the-box. I took me almost a day to figure out why. I took the 16 code and ran the upgrade command to 17. That was OK. But when I got to 18, things went wrong. The actual problem is the offer to migrate the code-base to the "new build system". This system no longer creates the expected runtime libraries. Instead, there's only main.js, and on inspection, this seemed to be just a server-side render of the application, not a runtilme library at all, even though server-side rendering is not enabled. So I just went through all the upgrades, being careful not to select the migration option each time. I was able to get it up to 20 with full compatibility with my framework. However, this causes a maintainance headache now. The only way to avoid the new buid system is to start from a version that doesn't have it, and progressively upgrade. In the long-term, it's possible that the new system will become mandatory, so my dev framework won't work anymore.
- The legacy framework used routing, but this wasn't required for a small application like this, so I removed the routing library. This library had resolvers, but these also aren't needed as the app, doesn't need to maintain state through reloads. Nonetheless, I left them in the code just to show how they are implmented.
## Breaking changes 
- The standalone build used to be for lightweight applications, but the Angular team have decided to make it the default. It sounds like the modular option is going to be deprecated eventually. Fortunately, there's a command to convert existing code. However, as expected, there were issues - the tool didn't pick up everything and I had to do some manual clean-ups.
- The dependency injection system has changed. YOu used to be able to just inject a service by supplying it as a parameter (similar to the MS MVC platform). Now, there's an explicit inject method. Fortunately, it wasn't a big deal. I consulted the documentation and had everything working in a few minutes.
- There are a number of new coding approaches in 18+, such as a new flow control syntax. I have tried to use these whereever possible. Signals are another big change, but I didn't need to use them in a simple application like this.

## Sidetracks
A couple of issues caused me significat frustration and time loss.
- The VS minification library I am using a old and slightly out-of-date. The better alternative is to use a Grunt script. There is a VS extension that promises to convert your bundleConfig.json file to a Grunt script. However, while it installed Grunt 5.0, it wrote the script in Grunt 3 syntax. I tried re-writing the script, but when this proved too difficult, I tried downgrading the Grunt library. But this broke dependencies, so it was back to the old library. It still works ok. (Also, the extension seemed to keep working even after I uninstalled it.)
- AI. When you create an Angular app now, you are asked if you want to enable AI coding support. Apparently, AI is capable of wring an entire app for you in any language if you tell it what you want. That sounded like a real labour-saving idea. As an engine, I selected Cursor, with hilarious results. Attempting to invoke the Generate Project command continually crashed in VS Code. I tried installing their native editor - same problem. Then I went to my Macbook and installed the engine and extension. Same problem. I found a disscusion on a Github forum describing the problem, but the discussion had been closed with no resolution. Oh, and the extension was in Mandarin initially. Somewhow it came good at some point. (I found a discussion explaining that sometimes it connects to the wrong AI engine.) That was about half a day wasted at that point. I can't understand how they can allow such a broken app in the wild.